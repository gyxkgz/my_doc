所谓的I/O重定向也就是让已创建的FD指向其他文件,在I/O重定向的过程中，不变的是FD 0/1/2代表STDIN/STDOUT/STDERR，变化的是文件描述符表中FD 0/1/2对应的具体文件，应用程序只关心前者。
>  输出重定向
<  输入重定向
>>追加输出重定向
&>或>& 输出和错误重定向，推荐前者，等效为>word 2>&1
&>> 追加重定向标准输出和错误 等效为>>word 2>&1

here document:   	
	<<定界符
	 内容
	定界符	
	将定界符之间的内容作为标准输入的内容
here strings：<<<string 将string作为标准输入的内容。

复制文件描述符：
n<& word ：复制输入文件描述符，n是word文件描述符的副本，如果word是-，文件描述符n关闭。
n>&word: 复制输出文件描述符

n<&digit-:移动文件描述符digit到n，digit关闭，不指定n默认为0
n>&digit-:移动文件描述符digit到n，digit关闭，不指定n默认为1

n<>word:可读可写，默认是0.

标准输入输出错误。


管道：
|，将管道前命令的输出作为管道后命令的输入。
|&，将管道前命令的标准错误加到标准输出作为管道后命令的输入。是2>&1|的简写。

重定向处理的顺序是从左到右，不同的顺序会得到不同的结果。ls > dirlist 2>&1会将标准输出和标准错误都输出到文件dirlist中。ls 2>&1 > dirlist则只会将标准输出输出到dirlist中。

noclobber开启则输出重定向文件名不能重名，必须是不存在的文件。

tee
________________________________________________________________________________________
常用的IO重定向方法有：

1、<：标准输入重定向

2、>：标准输出重定向，如果文件已存在则覆盖

3、>>：输出重定向，追加内容到文件末尾 

4、|：管道符，管道前的输出作为管道后的输入

5、tee：从标准输入读，写到标准输出和文件

6、<>:对文件可读可写，默认重定向标准输入（文件描述符0）

重定向处理的顺序是从左到右，不同的顺序会得到不同的结果。ls > dirlist 2>&1会将标准输出和标准错误都输出到文件dirlist中。ls 2>&1 > dirlist则只会将标准输出输出到dirlist中。

其他不常用的重定向方法：

&> file：标准输出和标准错误重定向到指定位置file，等效为>file 2>&1

&>>file:与上面的一样，只是内容追加到文件后

|&:将管道前命令的标准错误和标准输出作为管道后命令的输入，是2>&1|的简写。

复制文件描述符：
[n]<&file：输入文件描述符n是file文件描述符的副本，如果file是-，则关闭描述符n，默认n是0;
[n]>&file：输出文件描述符n是file文件描述符的副本，如果file是-，则关闭描述符n，默认n是1;

移动文件描述符：
n<&digit-:移动文件描述符digit到n，digit关闭，不指定n默认为0
n>&digit-:移动文件描述符digit到n，digit关闭，不指定n默认为1

Here Documents：将一段在shell输入的文本作为输入给到指定的文件描述符，默认是标准输入。格式为

                <<定界符

                    内容

                    定界符

Here strings：将输入的字符串输入到指定的文件描述符。格式如下:

                    <<<string


重定向原理：io重定向就是让已创建的文件描述符指向其他文件，在io重定向的过程中，文件描述符是不变的，比如0/1/2代表STDIN/STDOUT/STDERR，变化的是文件描述符表中对应的具体文件，应用程序只管调用文件描述符读写，而不管文件描述符指向什么文件。

详细内容查看man手册，man bash搜索redirection。

个人水平有限，肯定有疏漏和错误，欢迎大家批评指正和补充。
