Linux中很多设备都是字符设备，使用ls -l查看/dev下的设备，前面带c的都是字符设备。

字符设备的创建比较容易，而且有一套固定的模式，掌握了模式完全可以“套模板”。更多的精力应该花在业务逻辑的部分。

Linux的每个设备都有一个主设备号和次设备号，创建字符设备第一步就是给它分配设备号。如果是自己用，可以任意给定一个没有用过的设备号，也可以让系统自动分配。但是如果要发布给不同的人不同的机器使用，就不能随便。推荐使用系统自动分配的方式。
代码中根据有没有给定设备号决定是指定还是自动分配设备号，dev变量里包含了主设备号和次设备号。MKDEV就是将两个数字合成的。register_chrdev_region()函数注册字符设备，alloc_chrdev_region()函数自动分配设备号。主设备号是关键，次设备号可以看成是该类设备的计数。
通过MAJOR()可以得到主设备号。

字符设备一般会创建一个数据结构，里边包含了cdev结构、设备数据和其他数据，可以根据自己实际需求添加。然后创建该结构的指针。

分配完设备号，接下来给字符设备数据结构分配存储空间。

创建设备类

初始化字符设备、添加字符设备到内核和创建设备。

这里涉及到一个结构file_operations，这个结构里包含了文件操作函数列表，所有操作这个字符设备的动作函数地址都保存在这个结构里。结构的定义在头文件fs.h中，这个结构有很多内容，不过常用的就那么几个。

如果没遇到问题，到这里字符设备就创建成功了。如果失败，就会goto到错误处理的地方，这里用goto是因为失败后要把前面可能申请的资源释放掉，而且有顺序，这里一定要注意。

在exit函数中要有对应的注销或释放资源的操作，顺序跟创建时相反，后创建的先释放，先创建的后释放。

下面要完成的工作就是实现file_operations结构中的函数。对于简单的字符设备，最常见的操作是open、read、write、ioctl、release等。


open函数这里只是简单的获取了一下字符数据结构体的指针。container_of函数很有意思，可以根据结构成员的地址找到结构体数据的地址。

read函数要实现将内核空间的数据传到用户空间的功能，copy_to_user()函数就是干这个的，第一个和第三个参数就是read函数的形参，中间是内核的数据。这里的count是字节个数。

write函数实现的功能与read相反，使用copy_from_user()和memdup_user()函数可以实现。
ioctl函数实现一些设备独有操作的函数，i2c设备和spi设备就大量使用了ioctl。
release函数就是在设备文件关闭时需要做的操作。这里的关闭是指打开该文件的文件描述符个数为0了，如果不为0只会将计数减1而不会真正调用release函数。

具体的实例可以参看源码中i2c-dev.c中i2c设备驱动的实现。

必要的头文件：

编译模块并插入到内核后，在/dev目录下会创建对应的设备文件。

在/sys/class下会创建对应的设备类目录。


ok，以上就是简单的创建字符设备的过程，通过字符设备可以实现内核与用户空间的数据交换。学习字符设备的创建也是学习linux驱动开发的第一步。

（编译的方法在另一篇专栏linux中断中有提到）

限于个人水平，肯定有遗漏和错误，欢迎大家批评指正。
