中断是一颗芯片非常重要的功能之一，芯片没有了中断就像雷神没了他的锤头一样，“战斗力”大大下降。在Bumblebee内核用户手册中对中断的概述如下，很好的解释了中断机制和中断的核心知识点。


gd32vf103的中断配置大致分为下面几步：
1、打开全局中断；
2、设置优先级组；
3、打开对应设备的中断；
4、设置该设备中断的level级别和priority级别；
5、打开该设备具体某个功能的中断；
6、编写中断服务程序；

1、

在GD32VF103系列器件的系统架构示意图中，内核部分有一个ECLIC，这就是中断控制器，全称是“改进型内核中断控制器 （Enhanced Core Local Interrupt Controller，ECLIC）“，是基于RISC-V标准的CLIC优化而来。ECLIC是存储器映射单元，它的基地址是0xd2000000，寄存器和地址偏移如图所示：

它与核心的关系如下图所示。eclic左边进来的箭头是各种外设的中断源，右边出去的箭头是全局中断，我们要开的全局中断就是这个右边的箭头。只有打开它外设的中断才能告知处理器内核，它就是整个中断系统的总开关。

打开全局中断需要操作的寄存器是mstatus，它是内核寄存器，操作它直接使用单词mstatus，编译器就知道它是谁。它的控制位如图所示，bit3的MIE就是全局中断使能位，写1全局中断打开，写0全局中断关闭。

具体的代码如下：

set_csr是一个宏定义，具体内容为一串汇编。关于汇编的内容，我后边可能会写文章介绍（不敢挖这个坑）。

2、

ECLIC中断控制器的每个中断源都可以设置不同的级别（Level）和优先级（Priority），Level越大级别越高，高Level可以打断低Level的中断进而形成嵌套，在多个中断同时等待需要进行仲裁时要参考Level值。Priority是越大优先级越高，优先级不参与中断嵌套的判断，而是多个中断同时pending时，通过Priority来仲裁决定哪个中断发送到内核。

Bumblebee内核硬件实现使用了4位宽来配置Level和Priority，可以通过读取clicinfo寄存器的CLICINTCTLBITS得到。
配置优先级组其实就是如何将这4位分配给Level和Priority。通过 cliccfg 寄存器的nlbits指定Level的宽度，剩下的就是Priority的宽度。

如图配置blbits为2，就表示用两位表示level，2位表示Priority，那么level和Priority就可以各有4个等级；如果blbits为3，那么level就有8个等级，Priority只有一个等级。以此类推，所以一共可以有5种情况——blbits可以为0，1，2，3，4。

具体代码如下：

3、

在上文ECLIC与核心关系图中，左边有很多中断源，这些中断源有内核内部的，也有内核外部即外设的。Bumblebee 内核中0-18预留作为了内核特殊的内部中断，目前实际用到的只有4个。19以后是普通外部中断，到86就没了。实际起作用的中断源一共63个。

打开外设的中断就是要使能这些中断源，让对应的中断信号能够被ECLIC捕获。通过ECLIC寄存器clicintie[i]实现，i就是中断源的向量编号，它只有bit0有效，写1中断源被打开，写0中断源被屏蔽。

这里以串口0的中断为例，它的中断向量号是56，具体代码如下：

关于串口0的内容可以查看我的另一篇文章。
4、

我们前面已经讲过level和priority，这里就要给外设设置具体的值了，ECLIC就是通过比较这里设置的值来决定不同中断执行的先后顺序的。这里我设置level和priority都是1，寄存器是clicintctl[i]，它是8位的寄存器，bit[7:6]设置level，bit[5:4]设置priority。具体代码如下：

5、
通过上面的步骤，关于中断控制器本身的配置就完成了。下面我们需要在外设端打开对应的中断使能位。这里继续以串口0为例，控制寄存器0的bit5是读数据缓冲区非空中断和过载错误中断使能，就是我们需要的接收数据中断使能。

具体代码如下：

对于像串口0这种外设，它的功能中断有很多，比如接收数据非空、发送完成、错误、校验错误等等，而ECLIC的串口0中断源只有一个，也就是说所有外设的功能中断是或的关系，只要有一个触发就会触发串口0的中断，具体是什么中断需要我们在中断服务程序中判断。


6、
中断服务程序是在中断触发后执行的一段代码，虽然都是代码，但是它与普通代码有一些区别，比如执行的上下文环境不同，执行时芯片的模式不同，执行时间要求不同等等。
ECLIC的每个中断源可以配置成向量或者非向量模式，向量模式是每一个中断源有一个中断服务程序入口地址，中断触发后会直接跳到这个地址执行中断服务程序；而非向量模式是所有的非向量中断有一个公共地址，中断来了后会跳到这个公共地址处执行。关于它们的具体内容可以查阅Bumblebee内核数据手册，这里我们使用向量模式。
中断向量入口代码在start.S文件中，它是汇编写的启动文件，一般厂家会提供，他与手册中的中断向量表一一对应。

我们不能随意定义中断服务程序，关键字.word后的xxx_IRQHandler就是中断服务程序的函数名称，所以串口0的中断服务程序就应该这样：


这里就是判断一下是否是读数据缓冲区非空中断，如果是就读取数据。手册上有说”只要是对 USART_DATA 寄存器的一个读操作都可以清除 RBNE 位”，这里可以看出，如果连续接收n个数据，就会触发n次中断，而不是一个中断读取多个数据。对于大量数据的读取发送，最好采用DMA的方式。关于DMA我后边会写文章介绍。
这里还抛了一个问题，就是我这个uart_recv()函数内部是有一个临时变量来读取并保存数据的，但是如果我只调函数没有左边的赋值，中断就会出问题，本来一个中断变成了两个，搞不明白为什么，欢迎大家帮我解惑。

到这里中断的整个流程就走完了，当然严格来讲最开始还有eclic的初始化，这里工程自动帮我配置了，而且是在调用main之前，所以我就把它略过了。

实际做项目我想大家都会使用官方提供的sdk，那配置中断调用3个函数就搞定了，也就是把我上面1-4步的内容封装起来了。我傻傻的这么搞目的是要大家了解更多背后的东西，这样可能会对更好的理解和使用中断有所帮助。

ok，如果本文对你有所帮助，就用你们力所能及的方式支持我吧（点赞、投币、再看、分享都行）！

参考文档：《GD32VF103_User_Manual_CN_V1.2》，《Bumblebee core datasheet_cn》
